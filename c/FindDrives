/**
 * Find which drives are available for a given filecore filing system.
 */

#include <string.h>
#include <stdio.h>
#include "swis.h"

#include "FileCoreConstants.h"
#include "FindDrives.h"

#ifdef FORTIFY
#include "fortify.h"
#endif

#define DRIVE_MAX (8)


/*******************************************************************
 Function:      read_drive_name
 Description:   Read the name of a drive
 Parameters:    drive = drive number
                swinum_describe = SWI to describe the disc
                buffer-> disc name buffer to fill (at least 11 bytes)
 Returns:       pointer to the drive name or NULL if none could be read
 ******************************************************************/
static char *read_drive_name(int drive, unsigned swinum_describe, char *buffer)
{
    char disc_record[0x40] = {0};
    char name[10];
    int i;

    sprintf(name, ":%d", drive);
    if (_swix(swinum_describe, _INR(0,1), &name, &disc_record))
        return NULL;

    for (i=0; i<10; ++i)
    {
        char c = disc_record[0x16+i];
        if (c == ' ') c = '\0';
        buffer[i] = c;
        if (c == '\0')
            break;
    }
    buffer[10] = '\0';

    return buffer;
}


/*******************************************************************
 Function:      find_filecore_module_drives
 Description:   Find which FileCore drives are available for a given FS.
 Parameters:    modname-> module name, used for looking up SWI names
                ffmd_flags = FFMD_* flags to finding discs
                drive_callback -> function to call with the drive numbers
                private-> the private value to pass to callback function
 Returns:       none
 ******************************************************************/
void find_filecore_module_drives(const char *modname,
                                 unsigned long ffmd_flags,
                                 found_filecore_drive_f drive_callback,
                                 void *private)
{
    char buffer[32];
    unsigned swinum_drives;
    unsigned swinum_miscop;
    unsigned swinum_describe;
    unsigned floppies, winnies;
    int first_fixed;
    int drive;

    strcpy(buffer, modname);
    strcat(buffer, "_Drives");

    if (_swix(OS_SWINumberFromString, _IN(1) | _OUT(0), buffer, &swinum_drives) != 0)
        return;

    if (_swix(swinum_drives, _OUTR(1,2), &floppies, &winnies) != 0)
        return;

    strcpy(buffer, modname);
    strcat(buffer, "_MiscOp");
    if (_swix(OS_SWINumberFromString, _IN(1) | _OUT(0), buffer, &swinum_miscop) != 0)
        return;

    strcpy(buffer, modname);
    strcat(buffer, "_DescribeDisc");

    if (_swix(OS_SWINumberFromString, _IN(1) | _OUT(0), buffer, &swinum_describe))
        swinum_describe = 0;

    /* Decide where we split the removeable disc numbers, based on the flags from the FS */
    first_fixed = 4;
    {
        unsigned long *fs_descriptor;
        unsigned long fs_flags = 0;
        if (_swix(swinum_miscop, _IN(1)| _OUT(1),
                                 FileCore_MiscOp_ReadInfo,
                                 &fs_descriptor) == NULL)
            fs_flags = *fs_descriptor; /* Flags are in the first word */

        if (fs_flags & FileCore_DiscFlags_MountFloppiesLikeFixedDiscs)
        {
            /* Floppy discs range is really fixed discs */
            first_fixed = 0;
        }
        else if (fs_flags & FileCore_DiscFlags_HardDiscsCanEject)
        {
            /* Hard discs range is really floppies */
            first_fixed = 8;
        }
    }

    for (drive = 0; drive < DRIVE_MAX; ++drive)
    {
        bool is_removeable;
        bool want_name;
        unsigned long drive_status;
        char *name;

        is_removeable = (drive < first_fixed) ? true : false;
        if (drive < 4 && drive >= floppies)
        {
            /* This is in the range of floppy discs, and does not exist */
            continue;
        }
        if (drive >= 4 && drive >= winnies + 4)
        {
            /* This is in the range of hard discs, and does not exist */
            continue;
        }

        /* We now know that the disc is configured as existing, and whether the
         * disc is treated as removeable.
         */
        if (is_removeable)
        {
            if (!(ffmd_flags & FFMD_REPORT_REMOVABLE))
                continue; /* They don't care about removables */
            want_name = (ffmd_flags & FFMD_NAME_REMOVABLE) ? true : false;
        }

        if (!is_removeable)
        {
            if (!(ffmd_flags & FFMD_REPORT_FIXED))
                continue; /* They don't care about fixed discs */
            want_name = (ffmd_flags & FFMD_NAME_FIXED) ? true : false;
        }

        if (_swix(swinum_miscop, _INR(0,1)|_OUT(2), 7, drive, &drive_status) != NULL)
            drive_status = 0;

        if (drive_status & FileCore_MiscOp_ReadStatus_Absent)
        {
            /* Disc isn't really present - used for dynamic discs */
            continue;
        }

        name = NULL;
        if (want_name && swinum_describe)
            name = read_drive_name(drive, swinum_describe, buffer);

        drive_callback(private, drive, name, is_removeable);
    }
}
