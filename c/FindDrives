/**
 * Find which drives are available for a given filecore filing system.
 */

#include <string.h>
#include <stdio.h>
#include "swis.h"

#include "FindDrives.h"


/*******************************************************************
 Function:      read_drive_name
 Description:   Read the name of a drive
 Parameters:    drive = drive number
                swinum_describe = SWI to describe the disc
                buffer-> disc name buffer to fill (at least 11 bytes)
 Returns:       pointer to the drive name or NULL if none could be read
 ******************************************************************/
static char *read_drive_name(int drive, unsigned swinum_describe, char *buffer)
{
    char disc_record[0x40] = {0};
    char name[10];
    int i;

    sprintf(name, ":%d", drive);
    if (_swix(swinum_describe, _INR(0,1), &name, &disc_record))
        return NULL;

    for (i=0; i<10; ++i)
    {
        char c = disc_record[0x16+i];
        if (c == ' ') c = '\0';
        buffer[i] = c;
        if (c == '\0')
            break;
    }
    buffer[10] = '\0';

    return buffer;
}


/*******************************************************************
 Function:      find_filecore_module_drives
 Description:   Find which FileCore drives are available for a given FS.
 Parameters:    modname-> module name, used for looking up SWI names
                ffmd_flags = FFMD_* flags to finding discs
                drive_callback -> function to call with the drive numbers
                private-> the private value to pass to callback function
 Returns:       none
 ******************************************************************/
void find_filecore_module_drives(const char *modname,
                                 unsigned long ffmd_flags,
                                 found_filecore_drive_f drive_callback,
                                 void *private)
{
    char buffer[32];
    unsigned swinum;
    unsigned floppies, winnies;
    unsigned swinum_describe;
    int flags, drive;
    strcpy(buffer, modname);
    strcat(buffer, "_Drives");

    if (_swix(OS_SWINumberFromString, _IN(1) | _OUT(0), buffer, &swinum) != 0)
        return;

    if (_swix(swinum, _OUTR(1,2), &floppies, &winnies) != 0)
        return;

    strcpy(buffer, modname);
    strcat(buffer, "_MiscOp");
    if (_swix(OS_SWINumberFromString, _IN(1) | _OUT(0), buffer, &swinum) != 0)
        return;

    strcpy(buffer, modname);
    strcat(buffer, "_DescribeDisc");

    if (_swix(OS_SWINumberFromString, _IN(1) | _OUT(0), buffer, &swinum_describe))
        swinum_describe = 0;

    if (ffmd_flags & FFMD_REPORT_REMOVABLES)
    {
        for (drive = 0; drive < floppies; ++drive)
        {
            if (!_swix(swinum, _INR(0,1)|_OUT(2), 7, drive, &flags) && !(flags & 2))
            {
                char *name = NULL;
                if ((ffmd_flags & FFMD_NAME_REMOVABLES) && swinum_describe)
                    name = read_drive_name(drive, swinum_describe, buffer);
                drive_callback(private, drive, name);
            }
        }
    }
    if (ffmd_flags & FFMD_REPORT_HARDDISCS)
    {
        for (drive = 4; drive < 4+winnies; ++drive)
        {
            if (!_swix(swinum, _INR(0,1)|_OUT(2), 7, drive, &flags) && !(flags & 2))
            {
                char *name = NULL;
                if ((ffmd_flags & FFMD_NAME_HARDDISCS) && swinum_describe)
                    name = read_drive_name(drive, swinum_describe, buffer);
                drive_callback(private, drive, name);
            }
        }
    }
}
