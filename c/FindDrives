/**
 * Find which drives are available for a given filecore filing system.
 */

#include <string.h>
#include <stdio.h>
#include "swis.h"

#include "FileCoreConstants.h"
#include "FindDrives.h"

#ifdef FORTIFY
#include "fortify.h"
#endif

#define DRIVE_MAX (8)

/* Define this to debug this file */
/* #define DEBUG */


#ifdef DEBUG
#define dprintf if (1) printf
#else
#define dprintf if (0) printf
#endif


/*******************************************************************
 Function:      read_drive_name
 Description:   Read the name of a drive
 Parameters:    drive = drive number
                swinum_describe = SWI to describe the disc
                buffer-> disc name buffer to fill (at least 11 bytes)
 Returns:       pointer to the drive name or NULL if none could be read
 ******************************************************************/
static char *read_drive_name(int drive, unsigned swinum_describe, char *buffer)
{
    char disc_record[0x40] = {0};
    char name[10];
    int i;

    sprintf(name, ":%d", drive);
    if (_swix(swinum_describe, _INR(0,1), &name, &disc_record))
        return NULL;

    for (i=0; i<10; ++i)
    {
        char c = disc_record[0x16+i];
        if (c == ' ') c = '\0';
        buffer[i] = c;
        if (c == '\0')
            break;
    }
    buffer[10] = '\0';

    return buffer;
}


/*******************************************************************
 Function:      find_filecore_module_drives
 Description:   Find which FileCore drives are available for a given FS.
 Parameters:    modname-> module name, used for looking up SWI names
                ffmd_flags = FFMD_* flags to finding discs
                drive_callback -> function to call with the drive numbers
                private-> the private value to pass to callback function
 Returns:       none
 ******************************************************************/
void find_filecore_module_drives(const char *modname,
                                 unsigned long ffmd_flags,
                                 found_filecore_drive_f drive_callback,
                                 void *private)
{
    char buffer[32];
    unsigned swinum_drives;
    unsigned swinum_miscop;
    unsigned swinum_describe;
    unsigned floppies, winnies;
    int first_fixed;
    int drive;
    unsigned long fs_flags = 0;

    /* Special case some filing systems that have different SWI prefixes */
    if (strcmp(modname, "RAMFS") == 0)
        modname = "RamFS";

    strcpy(buffer, modname);
    strcat(buffer, "_Drives");

    if (_swix(OS_SWINumberFromString, _IN(1) | _OUT(0), buffer, &swinum_drives) != 0)
        return;

    if (_swix(swinum_drives, _OUTR(1,2), &floppies, &winnies) != 0)
        return;

    dprintf("floppies = %i, winnies = %i\n", floppies, winnies);

    strcpy(buffer, modname);
    strcat(buffer, "_MiscOp");
    if (_swix(OS_SWINumberFromString, _IN(1) | _OUT(0), buffer, &swinum_miscop) != 0)
        swinum_miscop = 0;

    strcpy(buffer, modname);
    strcat(buffer, "_DescribeDisc");

    if (_swix(OS_SWINumberFromString, _IN(1) | _OUT(0), buffer, &swinum_describe))
        swinum_describe = 0;

    /* Decide where we split the removeable disc numbers, based on the flags from the FS */
    first_fixed = 4;
    if (swinum_miscop)
    {
        unsigned long *fs_descriptor;
        if (_swix(swinum_miscop, _IN(1)| _OUT(1),
                                 FileCore_MiscOp_ReadInfo,
                                 &fs_descriptor) == NULL)
            fs_flags = *fs_descriptor; /* Flags are in the first word */
    }
    else
    {
        /* There is no _MiscOp, so assume the flags are 0 (eg RAMFS) */
        fs_flags = 0;
    }

    if (fs_flags & FileCore_DiscFlags_MountFloppiesLikeFixedDiscs)
    {
        /* Floppy discs range is really fixed discs */
        first_fixed = 0;
    }
    else if (fs_flags & FileCore_DiscFlags_HardDiscsCanEject)
    {
        /* Hard discs range is really floppies */
        first_fixed = 8;
    }

    for (drive = 0; drive < DRIVE_MAX; ++drive)
    {
        bool is_floppy; /* Indicates if it mounts like a floppy */
        bool is_removeable;
        bool is_ejectable;
        bool want_name;
        unsigned long drive_status;
        char *name;

        is_removeable = (drive < first_fixed) ? true : false;
        if (drive < 4 && drive >= floppies)
        {
            /* This is in the range of floppy discs, and does not exist */
            continue;
        }
        if (drive >= 4 && drive >= winnies + 4)
        {
            /* This is in the range of hard discs, and does not exist */
            continue;
        }

        if (drive < 4)
        {
            is_floppy = (fs_flags & FileCore_DiscFlags_MountFloppiesLikeFixedDiscs) ? false : true;
            is_ejectable = (fs_flags & FileCore_DiscFlags_FloppiesCanEject) ? true : false;
        }
        else
        {
            is_floppy = (fs_flags & FileCore_DiscFlags_HardDiscsCanMount) ? true : false;
            is_ejectable = (fs_flags & FileCore_DiscFlags_HardDiscsCanEject) ? true : false;
        }

        /* We now know that the disc is configured as existing, and whether the
         * disc is treated as removeable, floppy and ejectable.
         */
        if (is_removeable)
        {
            if (!(ffmd_flags & FFMD_REPORT_REMOVABLE))
                continue; /* They don't care about removables */
            want_name = (ffmd_flags & FFMD_NAME_REMOVABLE) ? true : false;
        }

        if (!is_removeable)
        {
            if (!(ffmd_flags & FFMD_REPORT_FIXED))
                continue; /* They don't care about fixed discs */
            want_name = (ffmd_flags & FFMD_NAME_FIXED) ? true : false;
        }

        if (swinum_miscop == 0 ||
            _swix(swinum_miscop, _INR(0,1)|_OUT(2), 7, drive, &drive_status) != NULL)
            drive_status = 0;

        dprintf("Drive %i has status flags &%x", drive, drive_status);

        if (drive_status & FileCore_MiscOp_ReadStatus_Absent)
        {
            /* Disc isn't really present - used for dynamic discs */
            continue;
        }

        name = NULL;
        if (want_name && swinum_describe)
            name = read_drive_name(drive, swinum_describe, buffer);

        drive_callback(private, drive, name, is_removeable, is_ejectable, is_floppy);
    }
}
