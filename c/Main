#include "FilerX.h"
#include "Tools.h"
#include "swis.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#ifdef FORTIFY
#include "fortify.h"
#endif

#include "ShareFS.h"

/* Define this to add in the support for checking discs */
#define SUPPORT_CHECK
/* Define this to add in the support for ejecting discs */
#define SUPPORT_EJECT

static char *share_styles[] =
    { "Not shared", "Share protected", "Share unprotected" };

static unsigned tray_window = 0;

enum menuitems_e {
    menuitem_namedisc,
    menuitem_dismount,
#ifdef SUPPORT_EJECT
    menuitem_eject,
#endif
    menuitem_format,
    menuitem_backup,
    menuitem_share,
    menuitem_verify,
#ifdef SUPPORT_CHECK
    menuitem_check,
#endif
    menuitem_free,
    menuitem_LAST
};

static struct drive_menu_s
{
    WimpMenu menu;
    WimpMenuItem more[9];
} drive_menu;

static WimpMenuItem *share_item = 0;

static struct
{
    FS      *fs;
    unsigned drive;
    int      x,y;
} menu_drive = { 0, 0, 0, 0 };

static WimpMenu name_menu;

static char new_name[12] = { 0 };

static struct share_menu_s
{
    WimpMenu menu;
    WimpMenuItem more[2];
} share_menu;


static void make_menu(WimpMenu *menu, const char *title)
{
    sprintf(menu->title, title);
    menu->title_fg    = 0x07;
    menu->title_bg    = 0x02;
    menu->work_fg     = 0x07;
    menu->work_bg     = 0x00;
    menu->item_width  = 0;
    menu->item_height = 44;
    menu->gap         = 0;
}

static void make_item(WimpMenuItem* item, const char *entry,
                       void *sub_or_win, bool shaded)
{
    item->flags = 0x00;
    item->submenu_or_window = sub_or_win ? sub_or_win : (void*)-1;
    item->icon_flags = 0x07000001 | (shaded ? WimpIcon_Shaded : 0);
    strcpy(item->icon_data.t,entry);
}

static void make_item_indir(WimpMenuItem* item,
                            char *buffer, char *validation, int buflen)
{
    item->flags = 0x00;
    item->submenu_or_window = (void*)-1;
    item->icon_flags = 0x07000001 | WimpIcon_Indirected;
    item->icon_data.it.buffer      = buffer;
    item->icon_data.it.validation  = validation;
    item->icon_data.it.buffer_size = buflen == 0 ? strlen(buffer) : buflen;
}

static void make_menus(void)
{
    WimpMenu *menu = (WimpMenu*)&share_menu;
    WimpMenuItem *items = menu->items;
    make_menu(menu, "Share style");
    make_item_indir(&items[0], share_styles[0], "", 0);
    make_item_indir(&items[1], share_styles[1], "", 0);
    make_item_indir(&items[2], share_styles[2], "", 0);
    items[2].flags |= WimpMenuItem_Last;

    make_menu(&name_menu, "Disc name");
    make_item_indir(&name_menu.items[0], new_name, "A~$&%@\\^:.#*\x22| ", 11);
    name_menu.items[0].flags |=  WimpMenuItem_Writable | WimpMenuItem_Last;

    menu = (WimpMenu*)&drive_menu;
    make_menu(menu, "xxFS::x");

    items = menu->items;

    make_item(&items[menuitem_namedisc], "Name disc", &name_menu,   false);
    make_item(&items[menuitem_dismount], "Dismount",   NULL,        false);
#ifdef SUPPORT_EJECT
    make_item(&items[menuitem_eject],    "Eject",     NULL,         true );
#endif
    make_item(&items[menuitem_format], "Format...",  NULL,        true );
    make_item(&items[menuitem_backup], "Backup...",  NULL,        true );
    make_item(&items[menuitem_share], "Share",     &share_menu,  false);
    make_item(&items[menuitem_verify], "Verify...",  NULL,        true );
#ifdef SUPPORT_CHECK
    make_item(&items[menuitem_check], "Check...",  NULL,        true );
#endif
    make_item(&items[menuitem_free], "Free...",    NULL,        false);
    items[menuitem_LAST - 1].flags |= WimpMenuItem_Last;
}

static void menu_shade(WimpMenu *menu, int item, bool shaded)
{
    WimpMenuItem *items = menu->items;

    if (shaded)
        items[item].flags = items[item].flags | WimpIcon_Shaded;
    else
        items[item].flags = items[item].flags & ~WimpIcon_Shaded;
}

static void get_icon_size(const char *icon, unsigned *x, unsigned *y)
{
    unsigned width,height,mode,xeig,yeig;
    _swi(Wimp_SpriteOp, _IN(0)|_IN(2)|_OUTR(3,4)|_OUT(6), 0x28,
        icon, &width, &height, &mode);

    _swi(OS_ReadModeVariable, _INR(0,1)|_OUT(2), mode, 4,  &xeig);
    _swi(OS_ReadModeVariable, _INR(0,1)|_OUT(2), mode, 5,  &yeig);

    *x = width  << xeig;
    *y = height << yeig;
}

static void create_icons(Drive *drive)
{
    if (drive->baricon == -1)
    {
        unsigned xsize,ysize;
        WimpCreateIconBlock cib;
        int icon;

        get_icon_size(drive->validation+1, &xsize, &ysize);
        cib.window_handle  = - 5;
        cib.icon.bbox.xmin =   0;
        cib.icon.bbox.ymin = -16;
        cib.icon.bbox.xmax =  xsize;
        cib.icon.bbox.ymax =  20 + ysize;
        cib.icon.flags     = 0x1700310b;
        cib.icon.data.ist.buffer      = drive->discname;
        cib.icon.data.ist.validation  = drive->validation;
        cib.icon.data.ist.buffer_size = strlen(drive->discname);

        icon_position(drive, &cib.window_handle, &icon);

        _swix(Wimp_CreateIcon, _INR(0,1)|_OUT(0), icon, &cib, &drive->baricon);
    }
}

static void remove_icons(Drive *drive)
{
    if (drive->baricon != -1)
    {
        WimpDeleteIconBlock dib;
        dib.window_handle = -2;
        dib.icon_handle   = drive->baricon;
        _swix(Wimp_DeleteIcon, _IN(1), &dib);
        drive->baricon = -1;
    }
}

static void update_icons(void)
{
    FS *fs;
    for (fs = fses; fs; fs = fs->next)
    {
        int n;
        for (n=0; n<8; ++n)
        {
            Drive *drive = &(fs->drive[n]);

            if (drive->validation[0] == 0)
                remove_icons(drive);
            else
                create_icons(drive);

        }
    }
}

static void clear_icons(void)
{
    FS *fs;
    for (fs = fses; fs; fs = fs->next)
    {
        int n;
        for (n=0; n<8; ++n)
        {
            Drive *drive = &(fs->drive[n]);
            drive->baricon = -1;
        }
    }
}

static void resize_icon(Drive *drive)
{
     unsigned xsize,ysize,textwidth;
     WimpGetIconStateBlock gisblock;
     WimpSetIconStateBlock sisblock;
     WimpCreateIconBlock ciblock;
     WimpDeleteIconBlock diblock;
     int icon;

     // Where is the icon in question?
     gisblock.window_handle = -2;
     gisblock.icon_handle   = drive->baricon;
     _swix(Wimp_GetIconState, _IN(1), &gisblock);

     // How big is the icon?
     get_icon_size(drive->validation+1, &xsize, &ysize);
     // And the text
     _swix(Wimp_TextOp, _INR(0,2) | _OUT(0),
               1, &new_name, 0, &textwidth);
     // Which is bigger?
     if (textwidth > xsize) xsize = textwidth;

     // Resize the icon
     _swix(Wimp_ResizeIcon, _INR(0,5),
               -2, drive->baricon,
               gisblock.icon.bbox.xmin,        -16,
               gisblock.icon.bbox.xmin + xsize, 20+ysize);

     // Refresh the icon
     sisblock.window_handle = -2;
     sisblock.icon_handle   = drive->baricon;
     sisblock.EOR_word = sisblock.clear_word = 0;
     _swix(Wimp_SetIconState, _IN(1), &sisblock);

     // Create and delete a dummy icon so the icons shuffle as meeded
     ciblock.window_handle  =  -5;
     ciblock.icon.bbox.xmin =   0;
     ciblock.icon.bbox.ymin = -16;
     ciblock.icon.bbox.xmax =  34;
     ciblock.icon.bbox.ymax =  54;
     ciblock.icon.flags     =   0;

     _swix(Wimp_CreateIcon, _INR(0,1)|_OUT(0), drive->baricon, &ciblock, &icon);
     diblock.window_handle = -2;
     diblock.icon_handle   = icon;
     _swix(Wimp_DeleteIcon, _IN(1), &diblock);
}

/*************************************************** Gerph *********
 Function:      menu_update
 Description:   Update the menu to reflect the selected FS and drive
 Parameters:    fs-> the FS we're operating on
                drive = the drive that's been selected
 Returns:       none
 ******************************************************************/
static void menu_update(FS *fs, int drive)
{
    sprintf(drive_menu.menu.title, "%s::%d", fs->fsparams->fsname, drive);

    /* Decide which operations are available by looking at the commands
       that can be performed. */

    printf("Attempting shading for %s, %i\n", fs->fsparams->fsname, drive);
#ifdef SUPPORT_EJECT
    menu_shade(&drive_menu.menu, menuitem_format,
               (bool)! fs->drive[drive].is_ejectable);
#endif
    printf("Format shading\n");

    /* Format */
    menu_shade(&drive_menu.menu, menuitem_format,
               (bool)! fsdrive_tool_capable(fs, menu_drive.drive, to_format));

#ifdef SUPPORT_CHECK
    /* Check */
    menu_shade(&drive_menu.menu, menuitem_check,
               (bool)! fsdrive_tool_capable(fs, menu_drive.drive, to_check));
#endif

    /* Verify */
    menu_shade(&drive_menu.menu, menuitem_verify,
               (bool)! fsdrive_tool_capable(fs, menu_drive.drive, to_verify));

    menu_drive.fs    = fs;
    menu_drive.drive = drive;
}

static void mouse_click(WimpMouseClickEvent *event)
{
    FS *fs = NULL;
    int drive = -1;

    if (event->window_handle == -2 && event->icon_handle != -1) // Icon bar
    {
        FS *f;
        for (f = fses; f; f = f->next)
        {
            int n;
            for (n = 0; n < 8; ++n)
            {
                if (f->drive[n].baricon == event->icon_handle)
                {
                    drive = n;
                    fs = f;
                }
            }
        }
    }

    if (fs == NULL || drive == -1)
        return;

    if (event->buttons == 4) // Select click on drive
    {
        char cmd[48];
        if (fs->drive[drive].discname[0] == ':')
            sprintf(cmd, "%%Filer_OpenDir %s:%s.$",
                         fs->fsparams->fsname, fs->drive[drive].discname);
        else
            sprintf(cmd, "%%Filer_OpenDir %s::%s.$",
                         fs->fsparams->fsname, fs->drive[drive].discname);

        _swix(OS_CLI, _IN(0), cmd);
    }

    if (event->buttons == 2) // Menu click on drive
    {
        menu_drive.fs    = fs;
        menu_drive.drive = drive;
        menu_drive.x     = event->mouse_x;
        menu_drive.y     = event->mouse_y;

        if (event->window_handle == -2)
        {
            menu_drive.x -= 0x40;
            menu_drive.y  = 96 + 44*menuitem_LAST;
        }

        sprintf(drive_menu.menu.title, "%s::%d", fs->fsparams->fsname, drive);

        if (sharefs)
        {
            WimpMenuItem *items = ((WimpMenu*)&share_menu)->items;
            int n;

            for (n=0; n<=2; ++n)
            {
                 if (fs->drive[drive].share == n)
                     items[n].flags |=  WimpMenuItem_Ticked;
                 else
                     items[n].flags &= ~WimpMenuItem_Ticked;
            }
            share_item->icon_flags &= ~WimpIcon_Shaded;
        }
        else
            share_item->icon_flags |=  WimpIcon_Shaded;

        menu_update(fs, drive);
        _swi(Wimp_CreateMenu, _INR(1,3), &drive_menu, menu_drive.x, menu_drive.y);
    }
}

static void menu_selection(WimpMenuSelectionEvent *event)
{
    if (menu_drive.fs != NULL && menu_drive.drive != -1)
    {
        WimpGetPointerInfoBlock pointer_info;
        Drive *drive = &menu_drive.fs->drive[menu_drive.drive];
        char discspec[16];
        int menuitem = (*event)[0];

        sprintf(discspec, "%s::%i", menu_drive.fs->fsparams->fsname, menu_drive.drive);

        switch (menuitem)
        {
        case menuitem_namedisc:
            if ((*event)[1] == 0)
            {
                _kernel_oserror *err;
                char cmd[32];
                sprintf(cmd, "%%Filer_CloseDir %s", discspec);
                _swix(OS_CLI, _IN(0), cmd);

                err = _swix(OS_FSControl, _INR(0,2), 50, discspec, new_name);
                if (err)
                    _swix(Wimp_ReportError, _INR(0,2), err, 1, 0);
                else
                {
                    strcpy(drive->discname, new_name);
                    resize_icon(drive);
                }
            }
            break;
        case menuitem_dismount:
            {
                _kernel_oserror *err;
                char cmd[32];
                sprintf(cmd, "%s:%%Dismount :%s",
                                  menu_drive.fs->fsparams->fsname,
                                  drive->discname);

                err = _swix(OS_CLI, _IN(0), cmd);
                if (err)
                    _swix(Wimp_ReportError, _INR(0,2), err, 1, 0);
            }
            break;
        case menuitem_share:
        {
            _kernel_oserror *err;
            ShareType sharetype = (ShareType)((*event)[1]);
            err = fsdrive_share(menu_drive.fs, menu_drive.drive, sharetype);
            if (err) _swix(Wimp_ReportError, _INR(0,2), err, 1, 0);
            break;
        }
#ifdef SUPPORT_EJECT
        case menuitem_eject:
            _swi(Wimp_ReportError, _INR(0,2), "0000Eject", 1, 0);
            break;
#endif
        case menuitem_backup:
            break;

        case menuitem_format:
#ifdef SUPPORT_CHECK
        case menuitem_check:
#endif
        case menuitem_verify:
            {
                tooloperation_t tooloperation;
                _kernel_oserror *err;

                if (menuitem == menuitem_format)
                    tooloperation = to_format;
                else if (menuitem == menuitem_check)
                    tooloperation = to_check;
                else /* Always default to verify */
                    tooloperation = to_verify;

                err = fsdrive_tool_invoke(menu_drive.fs, menu_drive.drive,
                                          tooloperation);
                if (err)
                    _swi(Wimp_ReportError, _INR(0,2), err, 1, 0);
            }
            break;

        case menuitem_free: // Free
            {
                char cmd[64];
                sprintf(cmd, "%%ShowFree -FS %s %d",
                             menu_drive.fs->fsparams->fsname, menu_drive.drive);
                _swix(OS_CLI, _IN(0), &cmd);
            }
            break;
        }

        _swix(Wimp_GetPointerInfo, _IN(1), &pointer_info);

        if (pointer_info.button_state & Wimp_MouseButtonAdjust)
        {
            menu_update(menu_drive.fs, menu_drive.drive);
            _swi(Wimp_CreateMenu, _INR(1,3),
                     &drive_menu, menu_drive.x, menu_drive.y);

        }
        else
        {
            menu_drive.fs    =  0;
            menu_drive.drive = -1;
        }
    }
}

int main(int argc, char *argv[])
{
    int message_list[] = { 0 };
    bool quit = false;
    UNUSED(argc);
    UNUSED(argv);

    _swi(Wimp_SlotSize, _INR(0,1), 16*1024, -1);

    _swi(Wimp_Initialise, _INR(0,3) | _OUT(1),
             310, 0x4b534154, "FilerX", &message_list,
             &task_handle);

    make_menus();
    update_icons();

    while (!quit)
    {
        static char poll_block[256];
        static unsigned int reason, data, sender;
        _swi(Wimp_Poll, _INR(0,1) | _IN(3) | _OUTR(0,2),
                        0x400001, poll_block, &pollword,
                        &reason, &data, &sender);

        if (quit)
            break;

        switch (reason)
        {
        case 6: // Mouse Click
            mouse_click((WimpMouseClickEvent*)poll_block);
            break;

        case 9: // Menu Selection
            menu_selection((WimpMenuSelectionEvent*)poll_block);
            break;

        case 13: // Pollword Non-Zero
            {
                if (pollword & Pollword_Drive) update_icons();
                pollword = 0;
            }
            break;

        case 17: // User Message
        case 18: // User Message Recorded
            {
            WimpUserMessageEvent *msg = (WimpUserMessageEvent*)poll_block;

            if (msg->hdr.action_code == 0) // Quit
            {
                quit = true;
                break;
            }
            
            break;
            }
        }
    }

    _swi(Wimp_CloseDown, _INR(0,1), task_handle, 0x4b534154);
    clear_icons();
    task_handle = 0;
}
