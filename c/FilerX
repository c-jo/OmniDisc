#include "kernel.h"
#include "FilerXHdr.h"
#include "FilerX.h"
#include "kernel.h"
#include "swis.h"

#include <stdbool.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>

char *strdup(const char *src)
{
    if (src == 0)
        return 0;
    char *tgt = malloc(strlen(src)+1);
    return strcpy(tgt, src);
}

unsigned task_handle;
unsigned pollword;

Drive *drives;
FS* fses;

static void add_drive(FS *fs, int drive)
{
    if (drive >=4 || fs->fd_names)
    {
        char buffer[48];
        strcpy(buffer, fs->name);
        strcat(buffer, "_DescribeDisc");

        unsigned swinum;
        if (_swix(OS_SWINumberFromString, _IN(1) | _OUT(0), buffer, &swinum))
            return;

        char name[4];
        char block[0x40];
        sprintf(name, ":%d", drive);
        if (_swix(swinum, _INR(0,1), &name, &block))
            return;

        char discname[12];
        int i;
        for (i=0; i<10; ++i)
        {
            char c = block[0x16+i];
            if (c == ' ') c = 0;
            discname[i] = c;
            if (c == 0) break;
        }

        Drive *drv = malloc(sizeof(Drive));
        drv->fs = fs;
        strcpy(drv->discname, discname);

        drv->validation = drive >= 4 ? fs->hvalidation : fs->fvalidation;

        drv->position = 0;
        drv->iconbar = 1;
        drv->drive = drive;
        drv->next  = drives;
        drv->prev  = 0;
        drives = drv;
    }
}

static void find_drives(FS *fs)
{
    char buffer[32];
    strcpy(buffer, fs->name);
    strcat(buffer, "_Drives");

    unsigned swinum;
    if (_swix(OS_SWINumberFromString, _IN(1) | _OUT(0), buffer, &swinum) != 0)
        return;

    unsigned floppies, winnies;
    if (_swix(swinum, _OUTR(1,2), &floppies, &winnies) != 0)
        return;

    strcpy(buffer, fs->name);
    strcat(buffer, "_MiscOp");
    if (_swix(OS_SWINumberFromString, _IN(1) | _OUT(0), buffer, &swinum) != 0)
        return;

    int flags, drive;
    for (drive = 0; drive < floppies; ++drive)
    {
        if (!_swix(swinum, _INR(0,1)|_OUT(2), 7, drive, &flags) && !(flags & 2))            add_drive(fs, drive);
   }
    for (drive = 4; drive < 4+winnies; ++drive)
    {
        if (!_swix(swinum, _INR(0,1)|_OUT(2), 7, drive, &flags) && !(flags & 2))            add_drive(fs, drive);
   }
}

static const void add_fs(const char *name, bool fd_names)
{
    FS *fs = malloc(sizeof(FS));
    strcpy(fs->name,   name);
    strcpy(fs->fvalidation, "Sfloppydisc");
    strcpy(fs->hvalidation, "Sharddisc");
    fs->fd_names = fd_names;

    char buffer[32];
    strcpy(buffer, name);
    strcat(buffer, "_DiscOp");

    fs->next = 0;
    fs->prev = fses;
    fses = fs;

    find_drives(fs);
}



static _kernel_oserror*cmd_desktop(const char* arg_string, void *pw)
{
    UNUSED(pw);

    if (task_handle == 0 || task_handle == -1)
    {
        return _swix(OS_Module, _INR(0,2), 2, Module_Title, arg_string);
    }
    return 0;

}

_kernel_oserror *module_cmd(const char *arg_string, int argc, int cmd_no,
                            void *pw)
{
    switch (cmd_no)
    {
        case 0: return cmd_desktop(arg_string, pw);
    }

    return 0;
}

_kernel_oserror *module_initialise(const char *cmd_tail, int podule_base,
                                   void *private_word)
{
    UNUSED(cmd_tail);
    UNUSED(podule_base);
    UNUSED(private_word);

    task_handle = 0;
    pollword = 0;
    fses = 0;
    drives = 0;

    add_fs("ADFS",   false);
    add_fs("SCSIFS", true );
    add_fs("SDFS",   true );

    _swi(TaskManager_StartTask,_IN(0),"Desktop_FilerX");
    
    return NULL;
}

_kernel_oserror *module_finalise(int fatal, int podule_base, void *private_word)
{
    UNUSED(fatal);
    UNUSED(podule_base);
    UNUSED(private_word);

    if (task_handle != 0 && task_handle != -1)
        _swi(Wimp_CloseDown, _INR(0,1), task_handle, 0x4b534154);

    return NULL;
}

void module_service(int service_number, _kernel_swi_regs *r, void *private_word)
{
    UNUSED(private_word);
    switch (service_number)
    {
/*
    case 0x11 : // Service_Memory
        if (r->r[2] == Image__RO_Base)
            r->r[1] = 0; // Refuse to release application workspace
        break;
*/
    case 0x49: // Service_StartWimp
        if (task_handle == 0)
        {
            task_handle = -1;
            r->r[0] = (int)"Desktop_FilerX";
            r->r[1] = 0; // Claim
        }
        break;

    case 0x4a: // Service_StartedWimp
        if (task_handle == -1)
            task_handle = 0;
        break;
    }
}

