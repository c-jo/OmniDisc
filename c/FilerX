#include "kernel.h"
#include "FilerXHdr.h"
#include "FilerX.h"
#include "FindDrives.h"
#include "Icon.h"

#include "kernel.h"
#include "swis.h"

#include <string.h>
#include <stdlib.h>
#include <stdio.h>

char *strdup(const char *src)
{
    char *tgt;
    if (src == 0)
        return 0;
    tgt = malloc(strlen(src)+1);
    return strcpy(tgt, src);
}

unsigned task_handle;
unsigned pollword;

Drive *drives;
FS    *fses;
Icon  *icons;

static void add_drive(FS *fs, int drive, const char *name, bool is_removeable)
{
    Drive *drv = malloc(sizeof(Drive));
    drv->fs = fs;
    if (name)
        strncpy(drv->discname, name, 10);
    else
        sprintf(drv->discname, ":%i", drive);

    drv->discname[10] = '\0';
    drv->validation = icon_find(icons, fs->name, drive, name);

    drv->position = 0; // **TODO** Determine position
    drv->iconbar  = true;

    drv->drive = drive;
    drv->next  = drives;
    drv->prev  = 0;

    drives = drv;
}


static void find_drives(FS *fs)
{
    unsigned long flags = FFMD_REPORT_REMOVABLE | FFMD_REPORT_FIXED | FFMD_NAME_FIXED;
    if (fs->fd_names)
        flags |= FFMD_NAME_REMOVABLE;
    find_filecore_module_drives(fs->name, flags,
                                (found_filecore_drive_f)add_drive, fs);
}


static const void add_fs(const char *name, bool fd_names)
{
    FS *fs = malloc(sizeof(FS));

    strcpy(fs->name,   name);
    fs->fd_names = fd_names;

    fs->next = 0;
    fs->prev = fses;
    fses = fs;

    find_drives(fs);
}



static _kernel_oserror*cmd_desktop(const char* arg_string, void *pw)
{
    UNUSED(pw);

    if (task_handle == 0 || task_handle == -1)
    {
        return _swix(OS_Module, _INR(0,2), 2, Module_Title, arg_string);
    }
    return 0;

}

static _kernel_oserror*cmd_add_fs(const char* arg_string, void *pw)
{
    static unsigned ra_buf[64];
    _kernel_oserror *e = 0;

    UNUSED(pw);

    e = _swix(OS_ReadArgs, _INR(0,3),
                  "fs/A,fdnames/S",
                  arg_string, &ra_buf, sizeof(ra_buf));
    if (e)
        return e;


    add_fs((char*)ra_buf[0], ra_buf[1] != 0);
    return 0;

}

_kernel_oserror *module_cmd(const char *arg_string, int argc, int cmd_no,
                            void *pw)
{
    switch (cmd_no)
    {
        case CMD_Desktop_FilerX:   return cmd_desktop (arg_string, pw);
        case CMD_FilerX_AddFS:     return cmd_add_fs  (arg_string, pw);
        case CMD_FilerX_DriveIcon: return icon_command(&icons, arg_string);
    }

    return 0;
}

_kernel_oserror *module_initialise(const char *cmd_tail, int podule_base,
                                   void *private_word)
{
    UNUSED(cmd_tail);
    UNUSED(podule_base);
    UNUSED(private_word);

    task_handle = 0;
    pollword    = 0;

    fses   = NULL;
    drives = NULL;
    icons  = NULL;

    //add_fs("ADFS",   false);
    //add_fs("SCSIFS", true );
    //add_fs("SDFS",   true );

    //_swi(TaskManager_StartTask,_IN(0),"Desktop_FilerX");

    return NULL;
}

_kernel_oserror *module_finalise(int fatal, int podule_base, void *private_word)
{
    UNUSED(fatal);
    UNUSED(podule_base);
    UNUSED(private_word);

    if (task_handle != 0 && task_handle != -1)
        _swi(Wimp_CloseDown, _INR(0,1), task_handle, 0x4b534154);

    return NULL;
}

void module_service(int service_number, _kernel_swi_regs *r, void *private_word)
{
    UNUSED(private_word);
    switch (service_number)
    {
/*
    case 0x11 : // Service_Memory
        if (r->r[2] == Image__RO_Base)
            r->r[1] = 0; // Refuse to release application workspace
        break;
*/
    case 0x49: // Service_StartWimp
        if (task_handle == 0)
        {
            task_handle = -1;
            r->r[0] = (int)"Desktop_FilerX";
            r->r[1] = 0; // Claim
        }
        break;

    case 0x4a: // Service_StartedWimp
        if (task_handle == -1)
            task_handle = 0;
        break;
    }
}

